Index: MAT210-MP1-RSA/mat210/Test.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package mat210;\r\n\r\n/**\r\n * Fichier distribué dans le cadre du cours MAT210, session automne 2021, à l'ÉTS.\r\n *\r\n * Par Xavier Provençal.\r\n *\r\n */\r\n\r\n\r\n/**\r\n * Exécute les tests contenus dans le fichier passé en argument.\r\n */\r\npublic class Test {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        // Les lignes suivantes forment une petite démonstration de la classe\r\n        // Entier. Vous pouvez les commenter après les avoir exécutées une\r\n        // fois.\r\n    \tEntier x = new Entier(\"2108\");\r\n    \tSystem.out.println(\"L'entier x est \" + x);\r\n        System.out.println(\"L'entier x est écrit sur sur \" + x.longueur() + \" chiffres.\");\r\n    \tSystem.out.println(\"La décimale en position 0 est : \" + x.getDecimale(0) + \" (décimale la plus à droite)\");\r\n    \tSystem.out.println(\"La décimale en position 1 est : \" + x.getDecimale(1));\r\n    \tSystem.out.println(\"La décimale en position 2 est : \" + x.getDecimale(2));\r\n    \tSystem.out.println(\"La décimale en position 3 est : \" + x.getDecimale(3) + \" (décimale la plus à gauche)\");\r\n    \tSystem.out.println(\"\");\r\n        System.out.print(\"On peut utiliser une boucle pour parcourir toutes les décimales de x :\");\r\n        for (int i=0; i<x.longueur(); i++) {\r\n            System.out.print(\" \" + x.getDecimale(i));\r\n        }\r\n        System.out.println(\"\\n\");\r\n    \t\r\n    \tEntier y = new Entier(\"34908230498320943209483209483204800927509247509824905709579284328809350138509832459040984569865842790289870398309432049849032240328490832049823094329048093284903848294089408920384902384234940824908329408\");\r\n    \tSystem.out.println(\"Par défaut, l'affichage d'un grand entier est tronqué, par exemple :\");\r\n    \tSystem.out.println(\"  y = \" + y);\r\n    \tSystem.out.println(\"On peut forcer l'affichage de toutes ces décimales avec la fonction .str()\");\r\n    \tSystem.out.println(\"  y = \" + y.str());\r\n    \tSystem.out.println(\"\");\r\n\r\n        // Si vous ne souhaitez pas utiliser les arguments de la ligne de\r\n        // commande, vous pouvez les simuler en réaffectant ``args`` sur un\r\n        // nouveau tableau de String.\r\n        //\r\n\r\n        // ATTENTION : pensez à commenter ces lignes AVANT de rendre votre travail !\r\n        //args = new String[] {\"chemin complet vers le fichier de tests à exécuter\"};\r\n    \t//args = new String[] {\"C:\\\\Users\\\\rayan\\\\MAT210\\\\MAT210-MP1-RSA\\\\tests\\\\additions1\"};\r\n        //args = new String[] {\"C:\\\\Users\\\\rayan\\\\MAT210\\\\MAT210-MP1-RSA\\\\tests\\\\additions2\"};\r\n    \targs = new String[] {\"C:\\\\Users\\\\rayan\\\\MAT210\\\\MAT210-MP1-RSA\\\\tests\\\\multiplications1\"};\r\n    \t//args = new String[] {\"C:\\\\Users\\\\rayan\\\\MAT210\\\\MAT210-MP1-RSA\\\\tests\\\\multiplications2\"};\r\n    \t//args = new String[] {\"C:\\\\Users\\\\rayan\\\\MAT210\\\\MAT210-MP1-RSA\\\\tests\\\\puissances\"};\r\n        //\r\n        TestParser.executeFichierDeTests(args[0]);\r\n    }\r\n}\r\n
===================================================================
diff --git a/MAT210-MP1-RSA/mat210/Test.java b/MAT210-MP1-RSA/mat210/Test.java
--- a/MAT210-MP1-RSA/mat210/Test.java	
+++ b/MAT210-MP1-RSA/mat210/Test.java	
@@ -48,7 +48,7 @@
         //args = new String[] {"chemin complet vers le fichier de tests à exécuter"};
     	//args = new String[] {"C:\\Users\\rayan\\MAT210\\MAT210-MP1-RSA\\tests\\additions1"};
         //args = new String[] {"C:\\Users\\rayan\\MAT210\\MAT210-MP1-RSA\\tests\\additions2"};
-    	args = new String[] {"C:\\Users\\rayan\\MAT210\\MAT210-MP1-RSA\\tests\\multiplications1"};
+    	args = new String[] {"C:\\Users\\Billion\\Documents\\ÉTS\\Semester2\\LOG121\\labs\\MAT210-Atelier1\\MAT210-MP1-RSA\\mat210\\Entier"};
     	//args = new String[] {"C:\\Users\\rayan\\MAT210\\MAT210-MP1-RSA\\tests\\multiplications2"};
     	//args = new String[] {"C:\\Users\\rayan\\MAT210\\MAT210-MP1-RSA\\tests\\puissances"};
         //
Index: MAT210-MP1-RSA/mat210/Entier.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package mat210;\r\n\r\n/**\r\n * Fichier distribué dans le cadre du cours MAT210, session automne 2021, à l'ÉTS.\r\n *\r\n * Par Xavier Provençal.\r\n *\r\n * Modifications par les étudiant·e·s : \r\n *  - TODO inscrivez vos noms ici.\r\n *  - TODO inscrivez vos noms ici.\r\n *  - TODO inscrivez vos noms ici.\r\n *  - TODO inscrivez vos noms ici.\r\n */\r\n\r\n\r\n\r\nimport java.util.ArrayList;\r\nimport java.lang.Math;\r\nimport java.util.Random;\r\n\r\n\r\n/**\r\n * Représente un entier positif (0 inclu), de taille arbitrairement grande.\r\n *\r\n * Pour être exact, la valeur maximum théorique est 10^Integer.MAX_VALUE - 1,\r\n * mais en pratique cette valeur est réduite par la taille de la pile (Java\r\n * heap space).\r\n *\r\n * Opérations supportées : addition, soustraction (avec résultat positif),\r\n * multiplication, puissance et modulo.\r\n */\r\npublic class Entier {\r\n\r\n    //\r\n    // DONNEES MEMBRES\r\n    //\r\n\r\n    /**\r\n     * Tableau dans lequel sont stockées les décimales de l'entier. La case 0\r\n     * contient le chiffre le moins significatif.\r\n     */\r\n    protected ArrayList<Integer> decimales;\r\n\r\n\r\n    //\r\n    // CONSTRUCTEURS\r\n    // \r\n\r\n    /**\r\n     * Constructeur vide, non accessible de l'extérieur de la classe.\r\n     */\r\n    private Entier() {\r\n        this.decimales = new ArrayList<Integer>();\r\n    }\r\n\r\n\r\n    /**\r\n     * Constructeur à partir d'un ``long``\r\n     *\r\n     * @param x  valeur de l'entier\r\n     */\r\n    public Entier(long x) {\r\n        this.decimales = new ArrayList<Integer>();\r\n        // x%10 donne la dernière décimale de x\r\n        // x/10 enlève la dernière décimale de x\r\n        do {\r\n            this.decimales.add((int) x%10);\r\n            x /= 10;\r\n        } while (x > 0);\r\n    }\r\n\r\n\r\n    /** \r\n     * Constructeur de copie.\r\n     *\r\n     * @param aCopier  Entier à copier\r\n     */\r\n    public Entier(Entier aCopier) {\r\n        this.decimales = new ArrayList<Integer>(aCopier.decimales);\r\n    }\r\n\r\n\r\n    /**\r\n     * Constructeur à partir d'une chaîne de caractères représentant un entier\r\n     * écrit en base 10.\r\n     *\r\n     * @param s  Représentation textuelle de l'entier, en base 10\r\n     */\r\n    public Entier(String s) {\r\n        this.decimales = new ArrayList<Integer>();\r\n        int zero_index = Character.getNumericValue('0');\r\n        for( int i=s.length()-1; i>=0; --i) {\r\n            this.decimales.add(Character.getNumericValue(s.charAt(i) - zero_index));\r\n        }\r\n    }\r\n\r\n\r\n\r\n    //\r\n    // OPÉRATIONS ARITHMÉTIQUES\r\n    // \r\n\r\n    /**\r\n     * Additionne l'entier spécifié à l'entier.\r\n     *\r\n     * Cette fonction ne modifie pas l'entier actuel (this), ni celui spécifié en\r\n     * paramètre. Un nouvel entier est retourné.\r\n     *\r\n     * @param autre  valeur à additionner\r\n     * @return  la somme de `this` et `autre`\r\n     */\r\n    public Entier somme(Entier autre) {\r\n        \r\n        // Exercice 1\r\n        //\r\n        // Déboguer cette fonction !\r\n        //\r\n        Entier somme = new Entier();\r\n        int decimale, retenue = 0;\r\n        int lng = Math.max(this.longueur(), autre.longueur());\r\n        for (int i=0; i<lng; ++i) {\r\n            // On utilise le fait que .getDecimale(i) retourne 0 si (i >= this.longueur())\r\n            decimale = this.getDecimale(i) + autre.getDecimale(i) + retenue;   // <--- bug\r\n            retenue = decimale / 10;\r\n            somme.decimales.add(decimale % 10);\r\n        }\r\n        if (retenue != 0) {                      // <--- bug\r\n            somme.decimales.add(retenue);\r\n        }\r\n        return somme;\r\n    }\r\n\r\n\r\n    public Entier multiplicationSimple(int valeur) {\r\n    \t\r\n    \tEntier multiplicationSimple = new  Entier();\r\n    \tint decimale, retenue = 0;\r\n    \tfor (int i = 0; i < this.longueur(); i++) {\r\n    \t\tdecimale = this.getDecimale(i) * valeur + retenue; \r\n    \t\tretenue = decimale / 10;\r\n    \t\tmultiplicationSimple.decimales.add(decimale % 10);\r\n\t\t}\r\n    \tif (retenue != 0) {                      \r\n            multiplicationSimple.decimales.add(retenue);\r\n        }\r\n\t\treturn multiplicationSimple;\r\n    }\r\n    \r\n    public Entier ajoutZero(int nbZero) {\r\n    \tint ZERO = 0;\r\n    \t\r\n    \tEntier ajoutZero = new Entier(this);\r\n    \tfor (int i = 0; i < nbZero; i++) {\r\n\t\t\tajoutZero.decimales.add(ZERO, 0);\r\n\t\t}\r\n    \t\r\n    \treturn ajoutZero;\r\n    }\r\n\r\n    /**\r\n     * Multiplie l'entier spécifié à l'entier.\r\n     *\r\n     * Cette fonction ne modifie pas l'entier actuel (this), ni celui spécifié en\r\n     * paramètre. Un nouvel entier est retourné.\r\n     *\r\n     * @param autre  valeur à multiplier\r\n     * @return  le produit de `this` et `autre`\r\n     * @throws CloneNotSupportedException \r\n     */\r\n    public Entier produit(Entier autre) {\r\n    \t\r\n    \tlong ZERO = 0;\r\n    \tEntier entierZero = new Entier(ZERO);\r\n    \tEntier produit = new Entier();\r\n\r\n    \tif(autre.longueur() < this.longueur()) {\r\n    \t\tentierZero = autre.produit(this);\r\n    \t} else if(this.estZero()) {\r\n    \t\treturn entierZero;\r\n    \t} else {\r\n    \t\tfor (int i = 0; i < this.longueur(); i++) {\r\n\t\t\t\tproduit = autre.multiplicationSimple(this.getDecimale(i));\r\n\t\t\t\tentierZero = entierZero.somme(produit.ajoutZero(i));\r\n\t\t\t}\r\n    \t}\r\n    \t\r\n    \treturn entierZero;\r\n    }\r\n    \r\n\r\n    /**\r\n     * Retourne le modulo l'entier par l'entier spécifié.\r\n     *\r\n     * Cette fonction ne modifie pas l'entier actuel (this), ni celui spécifié en\r\n     * pramètre. Un nouvel entier est retourné.\r\n     *\r\n     * @param p  exposant\r\n     * @return  la valeur de `this` à la puissance `p`\r\n     */\r\n    public Entier puissance(Entier p) {\r\n    \t\r\n    \tEntier reponse = new Entier(this);\r\n\r\n    \tif (p.estZero()) {\r\n    \t\treponse = new Entier(1);\r\n        } else  {\r\n            for (Entier i = new Entier(1); i.plusPetit(p); i = i.somme(new Entier(1))) {\r\n            reponse = this.produit(reponse);\r\n            }\r\n\t\t}\r\n        \r\n        return reponse;\r\n    }\r\n\r\n\r\n    /**\r\n     * Retourne le modulo l'entier par l'entier spécifié.\r\n     *\r\n     * Pré-condition : l'entier spécifié (m) ne doit pas être 0.\r\n     *\r\n     * Cette fonction ne modifie pas l'entier actuel (this), ni celui spécifié en\r\n     * paramètre. Un nouvel entier est retourné.\r\n     *\r\n     * @param m  valeur du modulo\r\n     * @return  la valeur de `this` modulo `m`\r\n     */\r\n    public Entier moduloNaif(Entier m) {\r\n\r\n        // Exercices 4.\r\n        //\r\n        // À compléter.\r\n        //\r\n        return null; // return bidon (pour que ça compile) À RETIRER !\r\n    }\r\n\r\n    /**\r\n     * Retourne le modulo l'entier par l'entier spécifié.\r\n     *\r\n     * Pré-condition : l'entier spécifié (m) ne doit pas être 0.\r\n     *\r\n     * Cette fonction ne modifie pas l'entier actuel (this), ni celui spécifié en\r\n     * paramètre. Un nouvel entier est retourné.\r\n     *\r\n     * @param m  valeur du modulo\r\n     * @return  la valeur de `this` modulo `m`\r\n     */\r\n    public Entier moduloOpt(Entier m) {\r\n\r\n        // Exercices 5.\r\n        //\r\n        // À compléter.\r\n        //\r\n        return null; // return bidon (pour que ça compile) À RETIRER !\r\n    }\r\n\r\n    /**\r\n     * Calcule du modulo\r\n     *\r\n     * @param m  valeur du modulo\r\n     * @return  la valeur de `this` modulo m\r\n     */\r\n    Entier modulo(Entier m) {\r\n        return this.moduloNaif(m);\r\n        //return this.moduloOpt(m);\r\n    }\r\n\r\n\r\n    /**\r\n     * Retourne (this^p) mod m, soit la p-ième puissance de l'entier, modulo m.\r\n     *\r\n     * Cette fonction ne modifie pas l'entier actuel (this), ni ceux spécifiés\r\n     * en paramètres. Un nouvel entier est retourné.\r\n     *\r\n     * @param p  valeur de l'exposant\r\n     * @param m  valeur du modulo\r\n     * @return  la valeur de `this` puissance `p` modulo `m`\r\n     */\r\n    public Entier puissanceModulaireNaif(Entier p, Entier m) {\r\n        \r\n        // Exercices 6.\r\n        //\r\n        // À réécrire\r\n        //\r\n        return (this.puissance(p)).modulo(m);\r\n    }\r\n\r\n    /**\r\n     * Retourne (this^p) mod m, soit la p-ième puissance de l'entier, modulo m.\r\n     *\r\n     * Cette fonction ne modifie pas l'entier actuel (this), ni ceux spécifiés\r\n     * en paramètres. Un nouvel entier est retourné.\r\n     *\r\n     * TODO Exercice 8 : expliquez le fait que cet fonction implémente\r\n     *                   l'algorithme \"puissance modulaire\" vu en classe.\r\n     *\r\n     *\r\n     * @param p  valeur de l'exposant\r\n     * @param m  valeur du modulo\r\n     * @return  la valeur de `this` puissance `p` modulo `m`\r\n     */\r\n    public Entier puissanceModulaireOpt(Entier p, Entier m) {\r\n        \r\n        // Exercices 7.\r\n        //\r\n        // À réécrire\r\n        //\r\n        return (this.puissance(p)).modulo(m);\r\n    }\r\n\r\n\r\n    /**\r\n     * Calcul de la puissance modulaire\r\n     *\r\n     * @param p  valeur de l'exposant\r\n     * @param m  valeur du modulo\r\n     * @return  la valeur de `this` puissance `p` modulo `m`\r\n     */\r\n    public Entier puissanceModulaire(Entier p, Entier m) {\r\n        return this.puissanceModulaireNaif(p, m);\r\n        //return this.puissanceModulaireOpt(p, m);\r\n    }\r\n\r\n\r\n    ///////////////////////////    ///////////////////////////    ///////////////////////////\r\n    ///////////////////////////    ///////////////////////////    ///////////////////////////\r\n    //                       //    //                       //    //                       //\r\n    //     Section BONUS     //    //     Section BONUS     //    //     Section BONUS     //\r\n    //                       //    //                       //    //                       //\r\n    ///////////////////////////    ///////////////////////////    ///////////////////////////\r\n    ///////////////////////////    ///////////////////////////    ///////////////////////////\r\n\r\n\r\n   /**\r\n     * Retourne un entier aléatoire formée de `n` chiffres.\r\n     *\r\n     * @param n  le nombre de chiffre dans l'écriture en base 10 de l'entier\r\n     * @return  un entier choisi pseudo-aléatoirement sur n chiffres.\r\n     */\r\n    public static Entier entierAleatoire(int n) {\r\n\r\n        Random generateur = new Random(); // générateur pseudo-aléatoire\r\n\r\n        // Pour des fins de débogage, il peut être utile d'utiliser toujours\r\n        // les mêmes nombres. Dans ce cas, utilisez la ligne suivante afin pour\r\n        // initialiser le générateur pseudo-aléatoire.\r\n        //Random generateur = new Random(0);\r\n\r\n\r\n        Entier nbAleat = new Entier();\r\n        for (int i = 0; i < n-1; i++) {\r\n           nbAleat.decimales.add(generateur.nextInt(10));\r\n        }\r\n        nbAleat.decimales.add(1 + generateur.nextInt(9)); // La dernière décimale ne doit pas être zéro\r\n        return nbAleat;\r\n    }\r\n\r\n    /**\r\n     * Exercice B1 : le test de Fermat !\r\n     *\r\n     * Cette fonction se base sur le petit théorème de Fermat (Théorème 2.11 à\r\n     * la page 98 des notes de cours) afin de déterminer si l'entier `p` est\r\n     * peut-être premier. Complétez la documentation qui suit.\r\n     *\r\n     *\r\n     * Si la fonction retourne `true`, cela signifie que \r\n     *\r\n     *   TODO identifiez la bonne réponse en supprimant les autres\r\n     *    - il est certain que p est premier\r\n     *    - il est certain que p n'est pas premier\r\n     *    - p est peut-être premier, peut-être pas.\r\n     *\r\n     *   TODO Justifiez votre réponse en vous basant sur le petit théorème de Fermat\r\n     *\r\n     *\r\n     *\r\n     * Si la fonction retourne `false`, cela signifie que \r\n     *\r\n     *   TODO identifiez la bonne réponse en supprimant les autres\r\n     *    - il est certain que p est premier\r\n     *    - il est certain que p n'est pas premier\r\n     *    - p est peut-être premier, peut-être pas.\r\n     *\r\n     *   TODO Justifiez votre réponse en vous basant sur le petit théorème de Fermat\r\n     *\r\n     * @param p  nombre à tester\r\n     * @return true si ???, false sinon\r\n     */\r\n    public static boolean testDeFermat(Entier p) {\r\n        Entier a = entierAleatoire(p.longueur() - 1); // a est plus petit que p\r\n        Entier x = a.puissanceModulaire(p.soustraire(new Entier(1)), p);\r\n        return x.estUn();\r\n    }\r\n\r\n\r\n    /**\r\n     * Utilise le test de Fermat afin de déterminer si l'entier `p` est\r\n     * peut-être premier avec un niveau de certitude donné par `niveauDeCertitude`.\r\n     *\r\n     * Le niveau de certitude est le nombre de fois que l'entier a passé \r\n     * le test de Fermat avec succès.\r\n     *\r\n     * Cette fonction effectue le test de Fermat sur l'entier `p` et retourne\r\n     * `true` si tous les tests sont positifs. La valeur `false` est retournée\r\n     * dès qu'un test est a échoué.\r\n     *\r\n     * @param  p  l'entier à tester\r\n     * @param  niveauDeCertitude le nombre de fois que le test de Fermat est utilisé\r\n     * @return  true si l'entier p a réussi tous les tests, false sinon.\r\n     */\r\n    public static boolean estPeutEtrePremier(Entier p, int niveauDeCertitude) {\r\n        //\r\n        // Exercice B2\r\n        //\r\n        // À compléter\r\n        //\r\n        return false; // return bidon à retirer\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Retourne un nombre à `n` chiffres qu'on pense être un nombre premier.\r\n     *\r\n     * Cette fonction choisit un nombre impair aléatoirement et utilise le test\r\n     * de Fermat afin de déterminer si le nombre est possiblement premier ou\r\n     * non.\r\n     *\r\n     * Le paramètre `niveauDeCertitude` indique le nombre de fois qu'un nombre\r\n     * doit réussir le test de Fermat pour être accepté comme nombre premier.\r\n     *\r\n     * Si le nombre échoue le test de Fermat, alors on lui additionne 2 et on\r\n     * recommence avec ce nouvel entier.\r\n     *\r\n     * Si le nombre passe avec succès le nombre requis de tests de Fermat,\r\n     * alors on considère qu'il est premier, même si nous ne pouvons pas en\r\n     * être absolument certain.\r\n     *\r\n     * @param  n le nombre chiffre dans l'écriture en base 10 de l'entier.\r\n     * @param  niveauDeCertitude  le nombre de fois que le nombre a passé avec succès le test de Fermat.\r\n     * @return  un nombre premier (probabiliste) à n chiffres.\r\n     */\r\n    public static Entier nbPremierAleatoireProbabiliste(int n, int niveauDeCertitude) {\r\n        Entier p = entierAleatoire(n);\r\n        if (p.estPair()) {\r\n            p = p.somme(new Entier(1));\r\n        }\r\n        //System.out.println(\"p est \" + p);\r\n        while (!estPeutEtrePremier(p, niveauDeCertitude)) {\r\n            p = p.somme(new Entier(2));\r\n            //System.out.println(\"p n'était pas premier, nouveau p \" + p);\r\n        }\r\n        return p;\r\n    }\r\n\r\n\r\n    /**\r\n     * Représente le résultat d'une division entière, c'est à dire un quotient\r\n     * et un reste.\r\n     *\r\n     * Par exemple, pour la division entière de 14 par 3 \r\n     * 14 = 4*3 + 2\r\n     *\r\n     * Le quotient est 4 et le reste est 2. L'objet ResultatDivisionEntiere\r\n     * correspondant serait donc construit de la manière suivante :\r\n     *\r\n     * ResultatDivisionEntiere resultat = new ResultatDivisionEntiere(new Entier(4), new Entier(2));\r\n     */\r\n    public static class ResultatDivisionEntiere {\r\n        public Entier quotient;\r\n        public Entier reste;\r\n        public ResultatDivisionEntiere(Entier quotient, Entier reste) {\r\n            this.quotient = quotient;\r\n            this.reste = reste;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Division entière\r\n     *\r\n     * Retourne le résultat de la division entière de `this` par `m`.\r\n     *\r\n     * Précondition : m n'est pas 0.\r\n     *\r\n     * @param m  le diviseur\r\n     * @return  le quotient et le reste\r\n     */\r\n    public ResultatDivisionEntiere divisionEntiere(Entier m) {\r\n        //\r\n        // Exercice B3\r\n        //\r\n        // À compléter\r\n        //\r\n        return null; // return bidon (pour que ça compile) À RETIRER !\r\n    }\r\n\r\n    /**\r\n     * Représente de résultat de l'algorithme de Bézout.\r\n     *\r\n     * Le thérorème de Bézout spécifie que pour toute paire d'entiers `a` et\r\n     * `b`, il existe deux entier `u` et `v` tels que \r\n     *\r\n     *   a*u + b*v = d = pgcd(a,b)\r\n     *\r\n     * L'objet ResultatBezout est formé des nombres u, v et d.\r\n     *\r\n     * Étant donné que `a` et `b` sont tous les deux positifs, les nombres u et\r\n     * v doivent être de signes opposés. Cependant, la classe Entier ne\r\n     * représente que des entiers positifs. Pour contrer ce problème, le\r\n     * booléen `uPositif` indique si l'entier `u` doit être considérer comme un\r\n     * nombre positif ou non.\r\n     *\r\n     * Concrètement : \r\n     *\r\n     *    Si `uPositif` est `true`  alors `u` est positif et `v` est négatif.\r\n     *        Autrement dit, a*u + b*(-v) = d = pgcd(a,b)\r\n     *\r\n     *    Si `uPositif` est `false` alors `u` est négatif et `v` est positif.\r\n     *        Autrement dit, a*(-u) + b*v = d = pgcd(a,b)\r\n     */\r\n    public static class ResultatBezout {\r\n        public Entier u; // multiplicateurs de u\r\n        public Entier v; // multiplicateurs de v\r\n        public Entier d; // pgcd(a,b)\r\n        public boolean uPositif;\r\n\r\n        ResultatBezout(Entier u, Entier v, Entier d, boolean uPositif) {\r\n            this.u = u;\r\n            this.v = v;\r\n            this.d = d;\r\n            this.uPositif = uPositif;\r\n        }\r\n    }\r\n\r\n    public static class EtapeEuclide {\r\n        public Entier a;\r\n        public Entier b;\r\n        public Entier quotient;\r\n        public Entier reste;\r\n        public EtapeEuclide(Entier a, Entier b, Entier quotient, Entier reste) {\r\n            this.a = a;\r\n            this.b = b;\r\n            this.quotient = quotient;\r\n            this.reste = reste;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Utilise l'algorithme d'Euclide afin de calculer le pgcd de `a` et `b`.\r\n     *\r\n     * Les coefficients de Bézout sont calculés au fur et à mesure de\r\n     * l'exécution de l'algorithme d'Euclide.\r\n     *\r\n     * @param a le premier Entier\r\n     * @param b le deuxième Entier\r\n     * @return  le résultat du Bézout de `a` et `b`\r\n     */\r\n    public static ResultatBezout bezout(Entier a, Entier b) {\r\n        //\r\n        // Exercice B4\r\n        //\r\n        // À compléter\r\n      \r\n        //  Aide pour le débogage: \r\n        //\r\n        //if (uPositif) {\r\n        //    System.out.println(\"\" + u + \"*\" + a + \" - \" + v + \"*\" + b + \" = \" + d);\r\n        //} else {\r\n        //    System.out.println(\"-\" + u + \"*\" + a + \" + \" + v + \"*\" + b + \" = \" + d);\r\n        //}\r\n        \r\n        return null; // return bidon (pour que ça compile) À RETIRER !\r\n\r\n    }\r\n\r\n    /**\r\n     * Plus grand commun diviseur via l'algorithme d'Euclide.\r\n     *\r\n     * Utilise la fonction `bezout` afin d'obtenir le pgcd des deux entiers.\r\n     *\r\n     * @param a  premier entier\r\n     * @param b  deuxième entier\r\n     * @return   le ggcd(a, b)\r\n     */\r\n    public static Entier pgcd(Entier a, Entier b) {\r\n        ResultatBezout r = bezout(a, b);\r\n        return r.d;\r\n    }\r\n\r\n    \r\n\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n////////////////////////////////////////////////////////////////////////////\r\n//// À partir d'ici, tout ce qui suit n'est pas pertinant dans le cadre ////\r\n//// du cours MAT210.                                                   ////\r\n////////////////////////////////////////////////////////////////////////////\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n    //\r\n    //AUTRES SERVICES\r\n    //\r\n    \r\n    /**\r\n     * Retourne ``vrai`` si l'entier est 0, ``faux`` sinon.\r\n     */\r\n    public boolean estZero() {\r\n        return longueur() == 1 && this.decimales.get(0) == 0;\r\n    }\r\n\r\n    /**\r\n     * Retourne ``vrai`` si l'entier est 1, ``faux`` sinon.\r\n     */\r\n    public boolean estUn() {\r\n        return longueur() == 1 && this.decimales.get(0) == 1;\r\n    }\r\n\r\n\r\n    /**\r\n     * Retourne ``vrai`` si l'entier est pair, ``faux`` sinon.\r\n     */\r\n    public boolean estPair() {\r\n        return this.getDecimale(0) % 2 == 0;\r\n    }\r\n\r\n    /**\r\n     * Retourne ``vrai`` si l'entier est impair, ``faux`` sinon.\r\n     */\r\n    public boolean estImpair() {\r\n        return this.getDecimale(0) % 2 == 1;\r\n    }\r\n\r\n    \r\n    /**\r\n     * Retourne la moitié arrondie à l'entier inférieur.\r\n     */\r\n    public Entier divParDeux() {\r\n        // On initialise un entier même lng avec des 0 partout.\r\n        Entier m = new Entier();\r\n        int n = this.longueur();\r\n        for (int i=0; i<n; ++i) {\r\n            m.decimales.add(0);\r\n        }\r\n        // Division par 2 comme on ferait à la main\r\n        int reste = 0;\r\n        for (int i=n-1; i>=0; --i) {\r\n            int d = this.getDecimale(i);\r\n            m.decimales.set(i, (reste*10+d)/2);\r\n            reste = d%2;\r\n        }\r\n        // Il est possible que le nombre commence par un 0, dans ce cas, on le retire.\r\n        m.retireZerosEnTete();\r\n        return m;\r\n    }\r\n\r\n\r\n    /**\r\n     * Retire les zéros à gauche.\r\n     *\r\n     * Si l'écriture en base 10 du nombre commence par des zéros, ceux-ci sont retirés.\r\n     * Ex : 00843 --> 843\r\n     * Exception : le nombre 0 est représenté par 0.\r\n     */\r\n    protected void retireZerosEnTete() {\r\n        int n = this.longueur();\r\n        while (n>1 && this.decimales.get(n-1) == 0) {\r\n            this.decimales.remove(n-1);\r\n            --n;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Retourne le nombre de décimales de l'entier. Il s'agit du nombre de\r\n     * chiffres nécessaire pour l'écrire en base 10.\r\n     */\r\n    public int longueur() {\r\n        return this.decimales.size();\r\n    }\r\n\r\n\r\n    /**\r\n     * Retourne la décimale à l'index spécifié. L'index 0 étant le chiffre le\r\n     * moins significatif de l'entier. Si l'index demandé est supérieur au\r\n     * nombre de décimales, retourne 0.\r\n     */\r\n    public int getDecimale(int k) {\r\n        if (k < this.longueur()) {\r\n            return this.decimales.get(k);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retourne la décimale la plus significative.\r\n     */\r\n    public int decimaleDeGauche() {\r\n        return this.getDecimale(this.longueur()-1);\r\n    }\r\n\r\n\r\n    /**\r\n     * Compare deux Entier.\r\n     * \r\n     * Retourne :\r\n     *  -1 si ``this`` < y\r\n     *   0 si ``this`` == y\r\n     *   1 si ``this`` > y\r\n     */\r\n    protected int compareTo(Entier y) {\r\n        // On utilise le fait que la fonction ``decimale(i)`` retourne 0\r\n        // lorsque ``i>=this.longueur()``\r\n        int n = Math.max(this.longueur(), y.longueur());\r\n        for (int i=n-1; i>=0; --i) {\r\n            int a = this.getDecimale(i);\r\n            int b = y.getDecimale(i);\r\n            if (a<b) {\r\n                return -1;\r\n            } else if (b<a) {\r\n                return 1;\r\n            }\r\n        }\r\n        // Si on est rendu ici, c'est que les deux sont égaux.\r\n        return 0;\r\n    }\r\n\r\n\r\n    /**\r\n     * Retourne ``vrai`` si et seulement si les deux entiers sont égaux.\r\n     */\r\n    public boolean egal(Entier y) {\r\n        return this.compareTo(y) == 0;\r\n    }\r\n\r\n\r\n    /**\r\n     * Retourne ``vrai`` si et seulement si l'entier est plus petit ou égal à\r\n     * celui spécifié.\r\n     */\r\n    public boolean plusPetitOuEgal(Entier y) {\r\n        return compareTo(y) <= 0;\r\n    }\r\n\r\n\r\n    /**\r\n     * Retourne ``vrai`` si et seulement si l'entier est strictement plus petit\r\n     * que celui spécifié.\r\n     */\r\n    public boolean plusPetit(Entier y) {\r\n        return compareTo(y) < 0;\r\n    }\r\n\r\n\r\n    /**\r\n     * Retourne ``vrai`` si et seulement si l'entier est strictement plus grand\r\n     * que celui spécifié.\r\n     */\r\n    public boolean plusGrand(Entier y) {\r\n        return compareTo(y) > 0;\r\n    }\r\n\r\n\r\n    /**\r\n     * Retourne ``vrai`` si et seulement si l'entier est plus grand ou égal à\r\n     * celui spécifié.\r\n     */\r\n    public boolean plusGrandOuEgal(Entier y) {\r\n        return compareTo(y) >= 0;\r\n    }\r\n\r\n\r\n    /**\r\n     * Retourne un nouvel entier égal au complément à dix de l'entier.\r\n     */\r\n    protected Entier complementADix(int taille) {\r\n        Entier c = new Entier();\r\n        int retenue = 1;\r\n        for (int i=0; i<taille; ++i) {\r\n            int decimale = 9-this.getDecimale(i)+retenue;\r\n            c.decimales.add(decimale%10);\r\n            retenue = decimale/10;\r\n        }\r\n        if (retenue>0) {\r\n            c.decimales.add(retenue);\r\n        }\r\n        return c;\r\n    }\r\n\r\n\r\n    /**\r\n     * Retire la décimale la plus à gauche de l'écriture en base 10 de\r\n     * l'entier.\r\n     * (sert uniquement lors de la soustraction via le complément à 10)\r\n     */\r\n    protected void retireDecimaleDeGauche() {\r\n        this.decimales.remove(this.longueur()-1);\r\n    }\r\n\r\n\r\n    /**\r\n     * Soustrait l'entier spécifié à l'entier.\r\n     *\r\n     * Pré-condition : l'entier actuel (this) doit absolument être plus grand\r\n     * que celui spécifié (y). (rappel : la classe Entier ne représente pas les\r\n     * négatifs)\r\n     *\r\n     * Cette fonction ne modifie pas l'entier actuel (this), ni celui spécifié en\r\n     * paramètre. Un nouvel entier est retourné.\r\n     *\r\n     */\r\n    public Entier soustraire(Entier y) {\r\n        if (this.plusPetit(y)) {\r\n            return null;\r\n        }\r\n        // On additionne le complément à 10\r\n        Entier diff = y.complementADix(this.longueur()).somme(this);\r\n        // On retire la retenue\r\n        diff.retireDecimaleDeGauche();\r\n        // On retire les zéro inutiles en début \r\n        while (diff.decimaleDeGauche() == 0 && !diff.estZero()) {\r\n            diff.retireDecimaleDeGauche();\r\n        }\r\n        return diff;\r\n    }\r\n\r\n\r\n    /**\r\n     * Retourne une chaîne de caractère représentant la valeur de l'entier en\r\n     * base 10. \r\n     *\r\n     * Dans le cas où l'écriture de l'entier fait plus de 80 chiffres, seuls\r\n     * les premières et les dernières décimales sont affichées. Utilisez la\r\n     * fonction ``str`` pour obtenir toutes les décimales de l'entier.\r\n     */\r\n\r\n    public String toString() {\r\n        StringBuilder sb = new StringBuilder();\r\n        int n = this.longueur();\r\n        if (n > 80) {\r\n            for (int i=0; i<30; ++i ) {\r\n                sb.append(getDecimale(n-i-1));\r\n            }\r\n            sb.append(\"...(\" + n + \" décimales)...\");\r\n            for (int i=29; i>=0; --i ) {\r\n                sb.append(getDecimale(i));\r\n            }\r\n            return sb.toString();\r\n        } else {\r\n            return str();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Retourne une chaîne de caractère représentant la valeur de l'entier en\r\n     * base 10. \r\n     */\r\n    public String str() {\r\n        StringBuilder sb = new StringBuilder();\r\n        for (int i=0; i<longueur(); ++i) {\r\n            sb.append(getDecimale(i));\r\n        }\r\n        return sb.reverse().toString();\r\n    }\r\n\r\n\r\n}\r\n
===================================================================
diff --git a/MAT210-MP1-RSA/mat210/Entier.java b/MAT210-MP1-RSA/mat210/Entier.java
--- a/MAT210-MP1-RSA/mat210/Entier.java	
+++ b/MAT210-MP1-RSA/mat210/Entier.java	
@@ -225,12 +225,15 @@
      * @return  la valeur de `this` modulo `m`
      */
     public Entier moduloNaif(Entier m) {
-
         // Exercices 4.
-        //
-        // À compléter.
-        //
-        return null; // return bidon (pour que ça compile) À RETIRER !
+        Entier entier = new Entier(this);
+
+        while(entier >= m)
+        {
+            entier = entier - m;
+        }
+
+        return entier;
     }
 
     /**
